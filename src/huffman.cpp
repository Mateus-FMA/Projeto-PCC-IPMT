#include "huffman.h"

#include <queue>

namespace ipmt {
namespace {

// Functor used to implement the partial order relation for the nodes on
// priority queue.
struct Compare {
  bool operator()(const HuffmanHeapNode *lhs, const HuffmanHeapNode *rhs) {
    return lhs->freq > rhs->freq;
  }
};

typedef std::priority_queue<HuffmanHeapNode*, std::vector<HuffmanHeapNode*>, Compare> HuffmanHeap;
typedef std::unordered_map<char, int> FrequencyTable;

// TODO(Mateus): supports ASCII alphabet only.
FrequencyTable ComputeFrequencyTable(const std::string &text) {
  FrequencyTable freq_table;

  for (size_t i = 0; i < text.size(); ++i) {
    ++freq_table[text[i]];
  }

  return freq_table;
}

void FillCodeTable(const HuffmanHeapNode *root, const DynamicBitset &codeword,
                   CodeTable *code_table) {
  if (!root) {
    return;
  } else if (!root->left && !root->right) {
    (*code_table)[root->c] = codeword;
  } else {
    DynamicBitset left_word = codeword;
    left_word.PushBack(false);
    FillCodeTable(root->left, left_word, code_table);

    DynamicBitset right_word = codeword;
    right_word.PushBack(true);
    FillCodeTable(root->right, right_word, code_table);
  }  
}

}  // namespace

HuffmanHeapNode* BuildTreeFromTable(const CodeTable &code_table) {
  HuffmanHeapNode *root = new HuffmanHeapNode;
  HuffmanHeapNode *current = root;

  for (auto it = code_table.begin(); it != code_table.end(); ++it) {
    DynamicBitset codeword = it->second;
    for (int j = 0; j < codeword.size(); ++j) {
      if (codeword[j]) {
        if (!current->right) current->right = new HuffmanHeapNode;
        current = current->right;
      } else {
        if (!current->left) current->left = new HuffmanHeapNode;
        current = current->left;
      }
    }

    // No need for the frequencies here.
    current->c = it->first;
    current = root;
  }

  return root;
}

// Returns the original text which the input code represents.
std::string HuffmanDecode(const DynamicBitset &code, HuffmanHeapNode *root) {
  if (root) {
    HuffmanHeapNode *current = root;
    std::string text;

    for (int i = 0; i < code.size(); ++i) {
      if (!current->left && !current->right) {
        text += current->c;
        current = root;
      }
      current = code[i] ? current->right : current->left;
    }

    return text;
  } else {
    return std::string();
  }
}

// Returns the Huffman code of the input text and a pointer to the tree generated by Huffman's
// algorithm. One must free the memory allocated for the tree structure in a further stage
// on application.
void HuffmanEncode(const std::string &text, DynamicBitset *code, CodeTable *code_table) {
  if (text.size() > 0) {
    // Build tree using Huffman's algorithm.
    FrequencyTable freq_table = ComputeFrequencyTable(text);
    HuffmanHeap min_heap;

    for (auto it = freq_table.begin(); it != freq_table.end(); ++it) {
      min_heap.push(new HuffmanHeapNode(it->first, it->second));
    }

    while (min_heap.size() > 1) {
      HuffmanHeapNode *x = min_heap.top();
      min_heap.pop();

      HuffmanHeapNode *y = min_heap.top();
      min_heap.pop();

      HuffmanHeapNode *z = new HuffmanHeapNode;
      z->left = x;
      z->right = y;      
      z->freq = x->freq + y->freq;
      min_heap.push(z); 
    }

    HuffmanHeapNode *root = min_heap.top();
    min_heap.pop();

    // Build code for this text.
    FillCodeTable(root, *code, code_table);
    delete root;

    for (size_t i = 0; i < text.size(); ++i) {
      DynamicBitset codeword = (*code_table)[text[i]];
      for (int j = 0; j < codeword.size(); ++j) {
        code->PushBack(codeword[j]);
      }
    }
  }
}

}  // namespace ipmt

